package pubsub

import (
	"context"
	"errors"
	"fmt"
	"github.com/redis/go-redis/v9"
	"sync"
	"time"
)

var (
	ErrNoEntryID = errors.New("no entry id")
)

// WithStream creates a new PubSub instance with Redis Stream.
// As the redis stream always returns the last delivered message,
// the lastSync is used to filter out the messages that are delivered before the lastSync.
// The internal worker just drops received events created before the lastSync.
func WithStream(c *redis.Client, lastSync int64) UnifiedPubSub {

	return &pubSubStreamImpl{
		client:    c,
		eventChan: make(chan Event),
		topics:    make(map[string]Topic),
		mu:        &sync.Mutex{},
		lastSync:  lastSync,
	}
}

type pubSubStreamImpl struct {
	client *redis.Client

	eventChan chan Event

	topics map[string]Topic

	mu *sync.Mutex

	worker Worker

	lastSync int64
}

// Publish publishes a message to a topic
func (ps *pubSubStreamImpl) Publish(context context.Context, event Event) error {

	id := event.ID()

	if id.EntryID == "" {
		id.EntryID = string(AutoGeneratedID)
	}

	jsonData := make(map[string]interface{})

	err := event.NormalizeInto(&jsonData)

	if err != nil {
		return err
	}

	entryID, err := ps.client.XAdd(context, &redis.XAddArgs{
		Stream:     id.Topic,
		NoMkStream: true,
		Approx:     true,
		ID:         id.EntryID,
		Values:     jsonData,
	}).Result()

	if err != nil {
		return err
	}

	if entryID == "" {
		return ErrNoEntryID
	}

	return nil
}

func (ps *pubSubStreamImpl) Subscribe(topics ...Topic) error {

	ps.mu.Lock()
	defer ps.mu.Unlock()

	updatedTopics := ps.updateTopics(topics)

	if updatedTopics == nil {
		return nil
	}

	if ps.worker != nil {
		oldWorker := ps.worker
		oldWorker.Stop()
		ps.worker = nil
		ps.lastSync = max(ps.lastSync, time.Now().UnixMilli())
	}

	ps.worker = NewStreamWorker(ps.client, ps.lastSync)

	return ps.worker.Run(updatedTopics, ps.eventChan)
}

func (ps *pubSubStreamImpl) Events() <-chan Event {
	return ps.eventChan
}

func (ps *pubSubStreamImpl) Errors() <-chan error {
	return nil
}

func (ps *pubSubStreamImpl) Topics() []string {
	ps.mu.Lock()
	defer ps.mu.Unlock()

	topics := make([]string, 0)

	for _, topic := range ps.topics {
		topics = append(topics, topic.Name())
	}

	return topics
}

func (ps *pubSubStreamImpl) Stop() (SyncPoint, error) {
	ps.mu.Lock()
	defer ps.mu.Unlock()

	if ps.worker == nil {
		return SyncPoint{}, nil
	}

	defer func() {
		ps.worker = nil
		close(ps.eventChan)
	}()

	fmt.Printf("Stopping StreamPubSub: %v\n", ps.worker)

	ps.worker.Stop()

	point := &SyncPoint{
		Timestamp: max(ps.lastSync, time.Now().UnixMilli()),
		Offsets:   make(map[string]string),
	}

	for _, topic := range ps.topics {
		point.Offsets[topic.Name()] = topic.Offset()
	}

	return *point, nil
}

func (ps *pubSubStreamImpl) updateTopics(topics []Topic) []Topic {

	topicAdded := false

	for _, topic := range topics {

		if _, ok := ps.topics[topic.Name()]; !ok {
			ps.topics[topic.Name()] = topic
			topicAdded = true
		}
	}

	if !topicAdded {
		return nil
	}

	targetTopics := make([]Topic, 0)

	for _, topic := range ps.topics {
		targetTopics = append(targetTopics, topic)
	}

	return targetTopics
}
