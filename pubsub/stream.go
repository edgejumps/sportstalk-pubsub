package pubsub

import (
	"context"
	"errors"
	"github.com/edgejumps/sportstalk-common-utils/logger"
	"github.com/redis/go-redis/v9"
	"sync"
	"time"
)

var (
	ErrNoEntryID         = errors.New("no entry id")
	ErrAlreadySubscribed = errors.New("already subscribed")
)

type pubSubStreamImpl struct {
	client *redis.Client

	working bool

	mu *sync.Mutex

	point *SyncPoint
}

func NewPubSubStream(c *redis.Client, point *SyncPoint) UnifiedPubSub {

	if point == nil {
		point = &SyncPoint{
			Offsets: make(map[string]string),
		}
	}

	return &pubSubStreamImpl{
		client: c,
		point:  point,
		mu:     &sync.Mutex{},
	}
}

func NewPubSubStreamWithSyncPoint(c *redis.Client, path string) UnifiedPubSub {

	point, err := LoadSyncPoint(path)

	if err != nil {
		logger.Error("Error loading sync point: ", err)
		return NewPubSubStream(c, nil)
	}

	return NewPubSubStream(c, point)
}

// Publish publishes a message to a topic
func (ps *pubSubStreamImpl) Publish(context context.Context, event Event) error {

	data, err := event.Data()

	if err != nil {
		return err
	}

	id := event.ID()

	if id.EntryID == "" {
		id.EntryID = string(AutoGeneratedID)
	}

	jsonData := make(map[string]interface{})

	err = data.NormalizeInto(&jsonData)

	if err != nil {
		return err
	}

	count, err := ps.client.XAdd(context, &redis.XAddArgs{
		Stream:     id.Topic,
		NoMkStream: true,
		Approx:     true,
		ID:         id.EntryID,
		Values:     jsonData,
	}).Result()

	if err != nil {
		return err
	}

	if count == "" {
		return ErrNoEntryID
	}

	return nil
}

func (ps *pubSubStreamImpl) Subscribe(context context.Context, topics ...TargetTopic) (<-chan Event, error) {

	ps.mu.Lock()
	defer ps.mu.Unlock()

	if ps.working {
		return nil, ErrAlreadySubscribed
	}

	msgs := make(chan Event)

	go ps.listen(context, msgs, topics...)

	ps.working = true

	return msgs, nil
}

func (ps *pubSubStreamImpl) listen(context context.Context, receiver chan<- Event, topics ...TargetTopic) {
	defer func() {
		close(receiver)
		ps.working = false
		logger.Info("pubsub stream closed")
	}()

	for {

		streams := make([]string, 0)

		for _, topic := range topics {

			v, ok := ps.point.Offsets[topic.Key]

			if !ok {
				v = string(MinimumID)
			}

			streams = append(streams, topic.Key, v)
		}

		select {
		case <-context.Done():
			return
		default:
			streams, err := ps.client.XRead(context, &redis.XReadArgs{
				Streams: streams,
			}).Result()

			if err != nil {
				return
			}

			for _, stream := range streams {
				for _, msg := range stream.Messages {

					timestamp := ParseTimestamp(msg.Values[EventTimestampKey])

					// if timestamp is less than or equal to the last read timestamp, skip
					if timestamp <= ps.point.Timestamp {
						continue
					}

					event := NewIncomingEvent(&EventID{
						Topic:   stream.Stream,
						EntryID: msg.ID,
					}, msg.Values)

					receiver <- event
					//ps.point.Timestamp = max(ps.point.Timestamp, timestamp)
				}

				if len(stream.Messages) > 0 {
					ps.point.Offsets[stream.Stream] = stream.Messages[len(stream.Messages)-1].ID
				}
			}
		}
	}
}

func (ps *pubSubStreamImpl) DumpSyncPoint(path string) error {

	ps.point.Timestamp = time.Now().UnixMilli()

	return DumpSyncPoint(path, ps.point)
}
